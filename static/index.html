<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>NOMYO Router Dashboard</title>
        <style>
            body {
                font-family: Arial, Helvetica, sans-serif;
                background: #e0e0e0;
                color: #333;
                padding: 20px;
            }
            .dark-mode {
                filter: invert(100%);
            }
            h2 {
                margin: 0;
            }
            #dark-mode-button {
                position: fixed; /* stays relative to the viewport */
                top: 1rem; /* distance from top edge */
                right: 1rem; /* distance from right edge */
                cursor: pointer;
                min-width: 1rem;
                min-height: 1rem;
                font-size: 1rem;
            }
            .tables-wrapper {
                display: flex;
                gap: 2rem;
            }
            .table-container {
                flex: 1;
                min-width: 350px;
                background: white;
                padding: 1rem;
                border-radius: 6px;
            }
            .endpoints-container {
                flex: 1;
                min-width: 350px;
                background: white;
                padding: 1rem;
                margin-top: 1rem;
                border-radius: 6px;
            }
            /* ---------- Header + Pull form ---------- */
            .header-pull-wrapper {
                display: flex;
                flex-direction: row;
                align-items: center;
                gap: 1rem;
                margin-bottom: 0;
            }

            #pull-section {
                display: flex;
                align-items: center;
            }
            #pull-section label {
                min-width: 30%;
            }
            #pull-section input {
                flex: 1;
                padding: 0;
                margin-right: 0.5rem;
                margin-left: 0.5rem;
                min-width: 50%;
                min-height: 1.5rem;
                text-align: left;
                text-indent: 0.25rem;
                outline: 0.1rem solid;
            }
            #pull-section button {
                padding: 0 0;
                cursor: pointer;
                background-color: #e0e0e0;
                color: black;
                border: none;
                outline: none;
                margin-left: 0.5rem;
                margin-right: 0.5rem;
                min-width: 30%;
                
                font-size: 1rem;
                transition: 0.3s;
            }
            #pull-section button:hover {
                background-color: #d1d1d1;
            }
            #pull-status {
                margin-left: 0.5rem;
                font-weight: bold;
            }
            /* ---------- Pull Endpoint Selection ---------- */
            #pull-endpoints-wrapper {
                margin-top: 0.5rem;
                padding: 0.5rem;
                border: 1px solid #ccc;
                border-radius: 4px;
                max-height: 150px;
                overflow-y: auto;
                display: none;
            }
            .endpoint-checkbox {
                display: flex;
                align-items: center;
                margin: 0.25rem 0;
            }
            .endpoint-checkbox input[type="checkbox"] {
                margin-right: 0.5rem;
            }
            .endpoint-checkbox label {
                cursor: pointer;
                font-size: 0.9rem;
            }
            /* ---------- Pull Progress Modal ---------- */
            #pull-modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                justify-content: center;
                align-items: center;
                z-index: 1000;
            }
            #pull-modal-content {
                background: #fff;
                padding: 1.5rem;
                max-width: 600px;
                width: 90%;
                max-height: 80%;
                overflow-y: auto;
                border-radius: 6px;
            }
            .pull-progress-item {
                margin-bottom: 1rem;
                padding: 0.5rem;
                border: 1px solid #e0e0e0;
                border-radius: 4px;
            }
            .pull-progress-endpoint {
                font-weight: bold;
                margin-bottom: 0.25rem;
                display: flex;
                align-items: center;
            }
            .pull-progress-endpoint .status-icon {
                margin-right: 0.5rem;
                font-size: 1.2rem;
            }
            .pull-progress-bar {
                height: 20px;
                background: #e0e0e0;
                border-radius: 4px;
                overflow: hidden;
                margin-bottom: 0.25rem;
            }
            .pull-progress-bar-fill {
                height: 100%;
                background: linear-gradient(90deg, #4CAF50, #45a049);
                transition: width 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 0.8rem;
                font-weight: bold;
            }
            .pull-progress-detail {
                font-size: 0.85rem;
                color: #666;
            }
            .pull-close-btn {
                float: right;
                cursor: pointer;
                font-size: 1.5rem;
                color: #666;
            }
            .pull-close-btn:hover {
                color: #333;
            }
            .pull-control-buttons {
                margin-top: 1rem;
                display: flex;
                gap: 0.5rem;
                justify-content: flex-end;
            }
            .pull-control-buttons button {
                padding: 0.5rem 1rem;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 0.9rem;
                font-weight: bold;
            }
            .pull-cancel-btn {
                background: #f44336;
                color: white;
            }
            .pull-cancel-btn:hover {
                background: #da190b;
            }
            .pull-restart-btn {
                background: #2196F3;
                color: white;
                display: none;
            }
            .pull-restart-btn:hover {
                background: #0b7dda;
            }
            .pull-cancel-btn:disabled,
            .pull-restart-btn:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }
            /* ---------- Tables ---------- */
            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 1rem;
            }
            th,
            td {
                border: 1px solid #ddd;
                padding: 0.5rem;
                text-align: left;
            }
            th {
                background: #e0e0e0;
            }
            .loading {
                color: #777;
                font-style: italic;
            }
            .status-ok {
                color: #006400;
                font-weight: bold;
            }
            .status-error {
                color: #8b0000;
                font-weight: bold;
            }
            .copy-link,
            .delete-link,
            .show-link {
                font-size: 0.9em;
                margin-left: 0.5em;
                cursor: pointer;
                text-decoration: underline;
                float: right;
            }
            .delete-link {
                color: #b22222;
            }
            .copy-link,
            .show-link {
                color: #0066cc;
            }
            .delete-link:hover,
            .copy-link:hover,
            .show-link:hover {
                text-decoration: none;
            }
            /* ---------- Modal ---------- */
            .modal {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.6);
                align-items: center;
                justify-content: center;
            }
            .modal-content {
                background: #fff;
                padding: 1rem;
                max-width: 90%;
                max-height: 90%;
                overflow: auto;
                border-radius: 6px;
            }
            .close-btn {
                float: right;
                cursor: pointer;
                font-size: 1.5rem;
            }
            /* ---------- Usage Chart ---------- */
            .usage-chart {
                margin-top: 20px;
            }
            .endpoint-bar {
                margin-bottom: 12px;
            }
            .endpoint-label {
                font-weight: bold;
                margin-bottom: 4px;
            }
            .bar {
                display: flex;
                height: 16px;
                background: #e0e0e0;
                border-radius: 4px;
                overflow: hidden;
            }
            .segment {
                height: 100%;
                color: white;
                font-size: 12px;
                font-weight: bolder;
                display: flex;
                align-items: center;
                justify-content: center;
                white-space: nowrap;
            }
            .table-container {
                padding-top: 1rem;
            }
            /* ---------- Responsive reorder ---------- */
            @media (max-aspect-ratio: 1/1) {
                .tables-wrapper {
                    flex-direction: column;
                }
                .tables-wrapper > .table-container:nth-child(1) {
                    /* Tags container */
                    order: 2;
                }
                .tables-wrapper > .table-container:nth-child(2) {
                    /* PS container */
                    order: 1;
                }
            }

            /* ========== Model Search & Pull Modal ========== */
            .search-modal-content {
                max-width: 800px;
                max-height: 80vh;
                overflow-y: auto;
            }

            .search-tabs {
                display: flex;
                border-bottom: 2px solid #e0e0e0;
                margin-bottom: 1rem;
            }

            .tab-btn {
                padding: 0.75rem 1.5rem;
                background: none;
                border: none;
                border-bottom: 3px solid transparent;
                cursor: pointer;
                font-size: 1rem;
                transition: all 0.2s;
            }

            .tab-btn:hover {
                background: #f5f5f5;
            }

            .tab-btn.active {
                border-bottom-color: #4CAF50;
                font-weight: bold;
            }

            .hw-status-panel {
                background: #f9f9f9;
                border: 1px solid #ddd;
                border-radius: 4px;
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .hw-metric {
                display: flex;
                justify-content: space-between;
                padding: 0.5rem 0;
            }

            .hw-value.error {
                color: #d32f2f;
                font-weight: bold;
            }

            .hw-value.warning {
                color: #f57c00;
                font-weight: bold;
            }

            .hw-value.ok {
                color: #388e3c;
            }

            .search-results {
                max-height: 400px;
                overflow-y: auto;
                border: 1px solid #ddd;
                border-radius: 4px;
                margin-top: 1rem;
            }

            .result-card {
                display: flex;
                align-items: center;
                padding: 0.75rem;
                border-bottom: 1px solid #eee;
                cursor: pointer;
                transition: background 0.2s;
            }

            .result-card:hover {
                background: #f5f5f5;
            }

            .result-card input[type="checkbox"] {
                margin-right: 1rem;
            }

            .result-info {
                flex: 1;
            }

            .result-name {
                font-weight: bold;
                font-size: 1.1rem;
            }

            .result-desc {
                color: #666;
                font-size: 0.9rem;
                margin-top: 0.25rem;
            }

            .result-meta {
                font-size: 0.85rem;
                color: #999;
                margin-top: 0.25rem;
            }

            .compatibility-indicator {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .compat-badge {
                padding: 0.25rem 0.5rem;
                border-radius: 3px;
                font-size: 0.85rem;
                font-weight: bold;
            }

            .compat-badge.ok {
                background: #c8e6c9;
                color: #2e7d32;
            }

            .compat-badge.warning {
                background: #ffe0b2;
                color: #e65100;
            }

            .compat-badge.error {
                background: #ffcdd2;
                color: #c62828;
            }

            .search-actions {
                display: flex;
                gap: 0.5rem;
                margin-top: 1rem;
                justify-content: flex-end;
            }
        </style>
    </head>
    <body>
        <a href="https://www.nomyo.ai" target="_blank"
            ><img src="./static/228394408.png" width="100px" height="100px"
        /></a>
        <h1>Router Dashboard</h1>

        <button onclick="toggleDarkMode()" id="dark-mode-button">
            üåó
        </button>

        <div class="tables-wrapper">
            <!-- ---------- Tags ---------- -->
            <div class="table-container">
                <div class="header-pull-wrapper">
                    <h2>
                        <span id="tags-count"></span> Available Models (Tags)
                    </h2>
                    <div id="pull-section">
                        <label for="pull-model-input">Pull a model: </label>
                        <input
                            type="text"
                            id="pull-model-input"
                            placeholder="llama3:latest"
                        />
                        <button id="pull-btn">Pull</button>
                        <button id="pull-config-btn" style="margin-left: 0.25rem;">Configure</button>
                        <button id="search-pull-btn" style="margin-left: 0.5rem;">üîç Search & Pull</button>
                        <span id="pull-status"></span>
                    </div>
                </div>

                <!-- Search box for models -->
                <div style="margin: 1rem 0;">
                    <input
                        type="text"
                        id="model-search"
                        placeholder="üîç Search models..."
                        style="width: 100%; padding: 0.5rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 4px;"
                    />
                </div>

                <!-- Endpoint selection (initially hidden) -->
                <div id="pull-endpoints-wrapper">
                    <label style="font-weight: bold; margin-bottom: 0.5rem; display: block;">
                        Select endpoints to pull to:
                    </label>
                    <div id="pull-endpoints-list">
                        <!-- Checkboxes populated dynamically -->
                    </div>
                </div>

                <table id="tags-table">
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Digest</th>
                        </tr>
                    </thead>
                    <tbody id="tags-body">
                        <tr>
                            <td colspan="2" class="loading">Loading‚Ä¶</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- ---------- PS + Usage Chart ---------- -->
            <div class="table-container">
                <h2>Running Models (PS)</h2>
                <table id="ps-table">
                    <thead>
                        <tr>
                            <th>Model</th>
                            <th>Params</th>
                            <th>Quant</th>
                            <th>Ctx</th>
                            <th>Digest</th>
                        </tr>
                    </thead>
                    <tbody id="ps-body">
                        <tr>
                            <td colspan="5" class="loading">Loading‚Ä¶</td>
                        </tr>
                    </tbody>
                </table>

                <!-- ------------- Usage Chart ------------- -->
                <div id="usage-chart" class="usage-chart"></div>
            </div>
        </div>
        <div class="endpoints-container">
            <h2>Configured Endpoints</h2>
            <table id="endpoints-table">
                <thead>
                    <tr>
                        <th>Endpoint</th>
                        <th>Status</th>
                        <th>Version</th>
                    </tr>
                </thead>
                <tbody id="endpoints-body">
                    <tr>
                        <td colspan="3" class="loading">Loading‚Ä¶</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <script>
            /* ---------- Utility ---------- */
            async function fetchJSON(url) {
                const resp = await fetch(url);
                if (!resp.ok) {
                    throw new Error(`Failed ${url}: ${resp.status}`);
                }
                return await resp.json();
            }

            function toggleDarkMode() {
                document.documentElement.classList.toggle("dark-mode");
            }

            /* ---------- Endpoints ---------- */
            async function loadEndpoints() {
                try {
                    const data = await fetchJSON("/api/config");
                    const body = document.getElementById("endpoints-body");
                    body.innerHTML = data.endpoints
                        .map((e) => {
                            const statusClass =
                                e.status === "ok"
                                    ? "status-ok"
                                    : "status-error";
                            const version = e.version || "N/A";
                            return `
        <tr>
          <td class="endpoint">${e.url}</td>
          <td class="status ${statusClass}">${e.status}</td>
          <td class="version">${version}</td>
        </tr>`;
                        })
                        .join("");

                    // NEU: Checkboxen f√ºr Ollama-Endpoints bef√ºllen
                    const ollamaEndpoints = data.endpoints.filter(e => !e.url.includes("/v1") && e.status === "ok");
                    const checkboxList = document.getElementById("pull-endpoints-list");
                    checkboxList.innerHTML = ollamaEndpoints
                        .map((e, idx) => `
                            <div class="endpoint-checkbox">
                                <input type="checkbox" id="ep-${idx}" value="${e.url}" checked>
                                <label for="ep-${idx}">${e.url}</label>
                            </div>`)
                        .join("");

                    window.availableEndpoints = ollamaEndpoints.map(e => e.url);

                } catch (e) {
                    console.error(e);
                    const body = document.getElementById("endpoints-body");
                    body.innerHTML = `<tr><td colspan="3" class="loading">Failed to load endpoints</td></tr>`;
                }
            }

            /* ---------- Tags ---------- */
            async function loadTags() {
                try {
                    const data = await fetchJSON("/api/tags");
                    const body = document.getElementById("tags-body");
                    body.innerHTML = data.models
                        .map((m) => {
                            let modelCell = `${m.model}`;
                            if (m.digest) {
                                modelCell += `<a href="#" class="delete-link" data-model="${m.name}">delete</a>`;
                                modelCell += `<a href="#" class="copy-link" data-source="${m.name}">copy</a>`;
                                modelCell += `<a href="#" class="show-link" data-model="${m.name}">show</a>`;
                            }
                            return `
        <tr>
          <td class="model">${modelCell}</td>
          <td>${m.digest || ""}</td>
        </tr>`;
                        })
                        .join("");
                    document.getElementById("tags-count").textContent =
                        `${data.models.length}`;

                    /* copy logic */
                    document.querySelectorAll(".copy-link").forEach((link) => {
                        link.addEventListener("click", async (e) => {
                            e.preventDefault();
                            const source = link.dataset.source;
                            const dest = prompt(
                                `Enter destination for ${source}:`,
                            );
                            if (!dest) return;
                            try {
                                const resp = await fetch(
                                    `/api/copy?source=${encodeURIComponent(source)}&destination=${encodeURIComponent(dest)}`,
                                    { method: "POST" },
                                );
                                if (!resp.ok)
                                    throw new Error(
                                        `Copy failed: ${resp.status}`,
                                    );
                                alert(
                                    `Copied ${source} to ${dest} successfully.`,
                                );
                                loadTags();
                            } catch (err) {
                                console.error(err);
                                alert(
                                    `Error copying ${source} to ${dest}: ${err}`,
                                );
                            }
                        });
                    });

                    /* delete logic */
                    document
                        .querySelectorAll(".delete-link")
                        .forEach((link) => {
                            link.addEventListener("click", async (e) => {
                                e.preventDefault();
                                const model = link.dataset.model;
                                const ok = confirm(
                                    `Delete the model ‚Äú${model}‚Äù? This cannot be undone.`,
                                );
                                if (!ok) return;
                                try {
                                    const resp = await fetch(
                                        `/api/delete?model=${encodeURIComponent(model)}`,
                                        { method: "DELETE" },
                                    );
                                    if (!resp.ok)
                                        throw new Error(
                                            `Delete failed: ${resp.status}`,
                                        );
                                    alert(
                                        `Model ‚Äú${model}‚Äù deleted successfully.`,
                                    );
                                    loadTags();
                                } catch (err) {
                                    console.error(err);
                                    alert(`Error deleting ${model}: ${err}`);
                                }
                            });
                        });

                    /* show logic */
                    document.body.addEventListener("click", async (e) => {
                        if (!e.target.matches(".show-link")) return;
                        e.preventDefault();
                        const model = e.target.dataset.model;
                        try {
                            const resp = await fetch(
                                `/api/show?model=${encodeURIComponent(model)}`,
                                { method: "POST" },
                            );
                            if (!resp.ok)
                                throw new Error(`Status ${resp.status}`);
                            const data = await resp.json();
                            document.getElementById("json-output").textContent =
                                JSON.stringify(data, null, 2).replace(
                                    /\\n/g,
                                    "\n",
                                );
                            document.getElementById(
                                "show-modal",
                            ).style.display = "flex";
                        } catch (err) {
                            console.error(err);
                            alert(
                                `Could not load model details: ${err.message}`,
                            );
                        }
                    });

                    /* pull logic */
                    /* Pull logic - mit Endpoint-Auswahl und Streaming */
                    let isPullInProgress = false;
                    let currentPullAbortController = null;

                    /* Check if model already exists on endpoints */
                    async function checkModelExists(model, endpoints) {
                        try {
                            const data = await fetchJSON("/api/tags");
                            const existingModels = data.models || [];

                            // Normalisiere Modellnamen (mit und ohne :latest)
                            const normalizedModel = model.includes(':') ? model : `${model}:latest`;
                            const modelVariants = [model, normalizedModel, model.replace(':latest', '')];

                            const endpointsWithModel = [];
                            const endpointsWithoutModel = [];

                            for (const endpoint of endpoints) {
                                // Pr√ºfe ob Model in der Liste existiert
                                const hasModel = existingModels.some(m =>
                                    modelVariants.some(variant =>
                                        m.name === variant || m.model === variant || m.name.startsWith(variant)
                                    )
                                );

                                if (hasModel) {
                                    endpointsWithModel.push(endpoint);
                                } else {
                                    endpointsWithoutModel.push(endpoint);
                                }
                            }

                            return { endpointsWithModel, endpointsWithoutModel };
                        } catch (e) {
                            console.error("Failed to check model existence:", e);
                            return { endpointsWithModel: [], endpointsWithoutModel: endpoints };
                        }
                    }

                    document.getElementById("pull-btn").addEventListener("click", async () => {
                        if (isPullInProgress) {
                            alert("A pull is already in progress. Please wait.");
                            return;
                        }

                        const model = document.getElementById("pull-model-input").value.trim();
                        if (!model) {
                            alert("Please enter a model name.");
                            return;
                        }

                        const checkboxes = document.querySelectorAll("#pull-endpoints-list input[type='checkbox']:checked");
                        const selectedEndpoints = Array.from(checkboxes).map(cb => cb.value);

                        if (selectedEndpoints.length === 0) {
                            alert("Please select at least one endpoint.");
                            return;
                        }

                        // Check if model already exists
                        const { endpointsWithModel, endpointsWithoutModel } = await checkModelExists(model, selectedEndpoints);

                        if (endpointsWithModel.length > 0) {
                            const endpointList = endpointsWithModel.map(ep => `  ‚Ä¢ ${ep}`).join('\n');
                            const message = `Model "${model}" already exists on:\n${endpointList}\n\nPull anyway?`;

                            if (!confirm(message)) {
                                return;
                            }
                        }

                        isPullInProgress = true;
                        await startPullStream(model, selectedEndpoints);
                        isPullInProgress = false;
                    });

                    /* Toggle Endpoint-Konfiguration */
                    document.getElementById("pull-config-btn").addEventListener("click", () => {
                        const wrapper = document.getElementById("pull-endpoints-wrapper");
                        wrapper.style.display = wrapper.style.display === "none" ? "block" : "none";
                    });

                    /* Pull Streaming Implementation */
                    let lastPullParams = null; // Speichert Model und Endpoints f√ºr Restart

                    async function startPullStream(model, endpoints) {
                        const modal = document.getElementById("pull-modal");
                        const modelSpan = document.getElementById("pull-modal-model");
                        const container = document.getElementById("pull-progress-container");
                        const cancelBtn = document.getElementById("pull-cancel-btn");
                        const restartBtn = document.getElementById("pull-restart-btn");

                        // Speichere Parameter f√ºr Restart
                        lastPullParams = { model, endpoints };

                        modelSpan.textContent = model;
                        modal.style.display = "flex";

                        // Zeige Cancel-Button, verstecke Restart-Button
                        cancelBtn.style.display = "inline-block";
                        cancelBtn.disabled = false;
                        restartBtn.style.display = "none";

                        container.innerHTML = endpoints
                            .map((ep) => {
                                const epId = btoa(ep).replace(/=/g, "");
                                return `
                                <div class="pull-progress-item" id="progress-${epId}">
                                    <div class="pull-progress-endpoint">
                                        <span class="status-icon">‚è≥</span>
                                        <span>${ep}</span>
                                    </div>
                                    <div class="pull-progress-bar">
                                        <div class="pull-progress-bar-fill" style="width: 0%;">0%</div>
                                    </div>
                                    <div class="pull-progress-detail">Waiting to start...</div>
                                </div>`;
                            })
                            .join("");

                        // AbortController f√ºr Cancel-Funktionalit√§t
                        currentPullAbortController = new AbortController();

                        try {
                            const response = await fetch("/api/pull-stream", {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ model, endpoints }),
                                signal: currentPullAbortController.signal
                            });

                            if (!response.ok) throw new Error(`HTTP ${response.status}`);

                            const reader = response.body.getReader();
                            const decoder = new TextDecoder();

                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;

                                const chunk = decoder.decode(value);
                                const lines = chunk.split("\n");

                                for (const line of lines) {
                                    if (line.startsWith("data: ")) {
                                        const eventData = JSON.parse(line.substring(6));
                                        handlePullEvent(eventData);
                                    }
                                }
                            }

                            // Download abgeschlossen - verstecke Cancel-Button
                            cancelBtn.style.display = "none";

                        } catch (err) {
                            if (err.name === 'AbortError') {
                                console.log("Pull cancelled by user");
                                // Zeige Restart-Button, verstecke Cancel-Button
                                cancelBtn.style.display = "none";
                                restartBtn.style.display = "inline-block";

                                // Markiere alle Endpoints als abgebrochen
                                endpoints.forEach(ep => {
                                    const epId = btoa(ep).replace(/=/g, "");
                                    const item = document.getElementById(`progress-${epId}`);
                                    if (item) {
                                        const icon = item.querySelector(".status-icon");
                                        const detail = item.querySelector(".pull-progress-detail");
                                        icon.textContent = "‚è∏Ô∏è";
                                        detail.textContent = "Cancelled - Click Restart to resume";
                                    }
                                });
                            } else {
                                console.error("Pull stream error:", err);
                                alert(`Pull failed: ${err.message}`);
                                modal.style.display = "none";
                                cancelBtn.style.display = "none";
                            }
                        } finally {
                            currentPullAbortController = null;
                        }
                    }

                    function handlePullEvent(event) {
                        const { type, endpoint, completed, total, status, message } = event;

                        if (type === "done") {
                            setTimeout(() => {
                                document.getElementById("pull-modal").style.display = "none";
                                loadTags();
                            }, 2000);
                            return;
                        }

                        if (!endpoint) return;

                        const epId = btoa(endpoint).replace(/=/g, "");
                        const item = document.getElementById(`progress-${epId}`);
                        if (!item) return;

                        const icon = item.querySelector(".status-icon");
                        const progressBar = item.querySelector(".pull-progress-bar-fill");
                        const detail = item.querySelector(".pull-progress-detail");

                        if (type === "progress") {
                            icon.textContent = "‚è≥";
                            if (total && total > 0) {
                                const percent = Math.round((completed / total) * 100);
                                progressBar.style.width = `${percent}%`;
                                progressBar.textContent = `${percent}%`;

                                const completedMB = (completed / 1024 / 1024).toFixed(1);
                                const totalMB = (total / 1024 / 1024).toFixed(1);
                                detail.textContent = `${status || "Downloading"}: ${completedMB} MB / ${totalMB} MB`;
                            } else {
                                detail.textContent = status || message || "Downloading...";
                            }
                        } else if (type === "complete") {
                            icon.textContent = "‚úÖ";
                            progressBar.style.width = "100%";
                            progressBar.textContent = "100%";
                            progressBar.style.background = "#4CAF50";
                            detail.textContent = "Complete";
                        } else if (type === "error") {
                            icon.textContent = "‚ùå";
                            progressBar.style.background = "#f44336";
                            detail.textContent = `Error: ${message}`;
                        } else if (type === "info") {
                            icon.textContent = "‚è≥";
                            detail.textContent = message || "Starting...";
                        }
                    }

                    /* Pull Modal Close Handler */
                    document.addEventListener("click", (e) => {
                        const pullModal = document.getElementById("pull-modal");
                        if (e.target === pullModal || e.target.matches(".pull-close-btn")) {
                            pullModal.style.display = "none";
                            // Reset buttons
                            document.getElementById("pull-cancel-btn").style.display = "none";
                            document.getElementById("pull-restart-btn").style.display = "none";
                        }
                    });

                    /* Cancel Button Handler */
                    document.getElementById("pull-cancel-btn").addEventListener("click", () => {
                        if (currentPullAbortController) {
                            currentPullAbortController.abort();
                            isPullInProgress = false;
                        }
                    });

                    /* Restart Button Handler */
                    document.getElementById("pull-restart-btn").addEventListener("click", async () => {
                        if (lastPullParams) {
                            isPullInProgress = true;
                            await startPullStream(lastPullParams.model, lastPullParams.endpoints);
                            isPullInProgress = false;
                        }
                    });

                    /* modal close */
                    const modal = document.getElementById("show-modal");
                    modal.addEventListener("click", (e) => {
                        if (
                            e.target === modal ||
                            e.target.matches(".close-btn")
                        ) {
                            modal.style.display = "none";
                        }
                    });
                } catch (e) {
                    console.error(e);
                }
            }

            /* ---------- PS ---------- */
            async function loadPS() {
                try {
                    const data = await fetchJSON("/api/ps");
                    const body = document.getElementById("ps-body");
                    body.innerHTML = data.models
                        .map(
                            (m) =>
                                `<tr><td class="model">${m.name}</td><td>${m.details.parameter_size}</td><td>${m.details.quantization_level}</td><td>${m.context_length}</td><td>${m.digest}</td></tr>`,
                        )
                        .join("");
                } catch (e) {
                    console.error(e);
                }
            }

            /* ---------- Usage Chart (stacked‚Äëpercentage) ---------- */
            function getColor(seed) {
                const h = Math.abs(hashString(seed) % 360);
                return `hsl(${h}, 80%, 30%)`;
            }
            function hashString(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash << 5) - hash + str.charCodeAt(i);
                    hash |= 0;
                }
                return Math.abs(hash);
            }
            async function loadUsage() {
                // Create the EventSource once and keep it around
                const source = new EventSource("/api/usage-stream");

                // -----------------------------------------------------------------
                // Helper that receives the payload and renders the chart
                // -----------------------------------------------------------------
                const renderChart = (data) => {
                    const chart = document.getElementById("usage-chart");
                    const usage = data.usage_counts || {};

                    let html = "";
                    for (const [endpoint, models] of Object.entries(usage)) {
                        const total = Object.values(models).reduce(
                            (a, b) => a + b,
                            0,
                        );

                        html += `<div class="endpoint-bar">
                 <div class="endpoint-label">${endpoint}</div>
                 <div class="bar">`;

                        for (const [model, count] of Object.entries(models)) {
                            const pct = total ? (count / total) * 100 : 0;
                            const width = pct.toFixed(2);
                            const color = getColor(model);
                            html += `<div class="segment"
                  style="width:${width}%;background:${color};">
                  ${model} (${count})
                </div>`;
                        }

                        html += `</div></div>`;
                    }
                    chart.innerHTML = html;
                };

                // -----------------------------------------------------------------
                // Event handlers
                // -----------------------------------------------------------------
                source.onmessage = (e) => {
                    try {
                        const payload = JSON.parse(e.data); // SSE sends plain text
                        renderChart(payload);
                    } catch (err) {
                        console.error("Failed to parse SSE payload", err);
                    }
                };

                source.onerror = (err) => {
                    console.error("SSE connection error. Retrying...", err);
                    // EventSource will automatically try to reconnect.
                };
                window.addEventListener("beforeunload", () => source.close());
            }

            /* ---------- Model Search ---------- */
            function initModelSearch() {
                const searchInput = document.getElementById("model-search");
                const tagsTable = document.getElementById("tags-table");

                if (searchInput && tagsTable) {
                    searchInput.addEventListener("input", (e) => {
                        const searchTerm = e.target.value.toLowerCase();
                        const tbody = tagsTable.querySelector("tbody");
                        const rows = tbody.querySelectorAll("tr");

                        let visibleCount = 0;

                        rows.forEach(row => {
                            // Skip loading/error rows
                            if (row.classList.contains("loading") || row.classList.contains("error")) {
                                return;
                            }

                            const modelCell = row.querySelector("td.model");
                            if (modelCell) {
                                const modelText = modelCell.textContent.toLowerCase();

                                if (modelText.includes(searchTerm)) {
                                    row.style.display = "";
                                    visibleCount++;
                                } else {
                                    row.style.display = "none";
                                }
                            }
                        });

                        // Update count to show filtered results
                        const countSpan = document.getElementById("tags-count");
                        if (countSpan && searchTerm) {
                            const totalCount = rows.length - (tbody.querySelector(".loading") ? 1 : 0);
                            countSpan.textContent = `${visibleCount} / ${totalCount}`;
                        }
                    });
                }
            }

            /* ---------- Model Search & Pull ---------- */
            let currentSearchTab = "ollama";
            let hardwareStats = null;

            // Open search modal
            document.getElementById("search-pull-btn").addEventListener("click", () => {
                document.getElementById("search-modal").style.display = "flex";
                loadHardwareStatus();
                searchModels("");  // Load initial results
            });

            // Tab switching
            document.querySelectorAll(".tab-btn").forEach(btn => {
                btn.addEventListener("click", (e) => {
                    document.querySelectorAll(".tab-btn").forEach(b => b.classList.remove("active"));
                    e.target.classList.add("active");
                    currentSearchTab = e.target.dataset.tab;
                    searchModels(document.getElementById("model-search-input").value);
                });
            });

            // Search input
            let searchTimeout;
            document.getElementById("model-search-input").addEventListener("input", (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    searchModels(e.target.value);
                }, 300);
            });

            // Load hardware status
            async function loadHardwareStatus() {
                try {
                    const data = await fetchJSON("/api/hardware");
                    hardwareStats = data;

                    // Update UI
                    const diskEl = document.getElementById("hw-disk");
                    const ramEl = document.getElementById("hw-ram");
                    const cpuEl = document.getElementById("hw-cpu");

                    // Disk
                    diskEl.textContent = `${data.disk.available_gb}GB / ${data.disk.total_gb}GB (${100 - data.disk.used_percent}% free)`;
                    if (data.disk.available_gb < 0.1) {
                        diskEl.className = "hw-value error";
                    } else if (data.disk.available_gb < 2.0) {
                        diskEl.className = "hw-value warning";
                    } else {
                        diskEl.className = "hw-value ok";
                    }

                    // RAM
                    ramEl.textContent = `${data.ram.available_gb}GB / ${data.ram.total_gb}GB`;
                    if (data.ram.available_gb < 2.0) {
                        ramEl.className = "hw-value error";
                    } else if (data.ram.available_gb < 4.0) {
                        ramEl.className = "hw-value warning";
                    } else {
                        ramEl.className = "hw-value ok";
                    }

                    // CPU
                    cpuEl.textContent = `${data.cpu.cores} cores`;
                    cpuEl.className = data.cpu.cores >= 4 ? "hw-value ok" : "hw-value warning";

                } catch (e) {
                    console.error("Failed to load hardware status:", e);
                }
            }

            // Search models
            async function searchModels(query) {
                const resultsDiv = document.getElementById("search-results");
                resultsDiv.innerHTML = '<div style="padding: 2rem; text-align: center;">Searching...</div>';

                try {
                    let data;
                    if (currentSearchTab === "ollama") {
                        data = await fetchJSON(`/api/search/ollama?query=${encodeURIComponent(query)}&limit=20`);
                    } else {
                        data = await fetchJSON(`/api/search/hf?query=${encodeURIComponent(query)}&limit=20`);
                    }

                    if (!data.models || data.models.length === 0) {
                        resultsDiv.innerHTML = '<div style="padding: 2rem; text-align: center; color: #999;">No models found</div>';
                        return;
                    }

                    // Render results
                    resultsDiv.innerHTML = data.models.map(model => {
                        if (currentSearchTab === "ollama") {
                            const compat = model.compatibility || {};
                            const compatClass = compat.status || "ok";
                            const compatText = compat.compatible === false ? "Blocked" :
                                               compat.status === "warning" ? "Warning" : "OK";
                            const disabled = compat.compatible === false ? "disabled" : "";

                            return `
                                <div class="result-card">
                                    <input type="checkbox" class="model-checkbox" data-model="${model.name}" ${disabled}>
                                    <div class="result-info">
                                        <div class="result-name">${model.name}</div>
                                        <div class="result-desc">${model.description}</div>
                                        <div class="result-meta">
                                            ${model.size_gb}GB ‚Ä¢ ${model.parameter_count} ‚Ä¢ ${model.tags.join(", ")}
                                        </div>
                                    </div>
                                    <div class="compatibility-indicator">
                                        <span class="compat-badge ${compatClass}">${compatText}</span>
                                    </div>
                                </div>
                            `;
                        } else {
                            // HuggingFace
                            return `
                                <div class="result-card">
                                    <input type="checkbox" class="model-checkbox" data-model="${model.id}">
                                    <div class="result-info">
                                        <div class="result-name">${model.id}</div>
                                        <div class="result-desc">${model.description || "No description"}</div>
                                        <div class="result-meta">
                                            ‚¨áÔ∏è ${(model.downloads / 1000).toFixed(0)}K downloads ‚Ä¢ ‚ù§Ô∏è ${model.likes} likes ‚Ä¢ ${model.pipeline_tag}
                                        </div>
                                    </div>
                                    <div class="compatibility-indicator">
                                        <span class="compat-badge ok">Inference API</span>
                                    </div>
                                </div>
                            `;
                        }
                    }).join("");

                    // Update pull button state
                    updatePullButtonState();

                    // Add checkbox listeners
                    document.querySelectorAll(".model-checkbox").forEach(cb => {
                        cb.addEventListener("change", updatePullButtonState);
                    });

                } catch (e) {
                    console.error("Search failed:", e);
                    resultsDiv.innerHTML = `<div style="padding: 2rem; text-align: center; color: #d32f2f;">Search failed: ${e.message}</div>`;
                }
            }

            // Update pull button state
            function updatePullButtonState() {
                const checkedBoxes = document.querySelectorAll(".model-checkbox:checked");
                const pullBtn = document.getElementById("pull-selected-btn");

                if (checkedBoxes.length > 0) {
                    pullBtn.disabled = false;
                    pullBtn.textContent = `Pull ${checkedBoxes.length} Model(s)`;
                } else {
                    pullBtn.disabled = true;
                    pullBtn.textContent = "Pull Selected";
                }
            }

            // Pull selected models
            document.getElementById("pull-selected-btn").addEventListener("click", () => {
                const checkedBoxes = document.querySelectorAll(".model-checkbox:checked");
                const modelNames = Array.from(checkedBoxes).map(cb => cb.dataset.model);

                if (modelNames.length === 0) return;

                // Close search modal
                document.getElementById("search-modal").style.display = "none";

                // For Ollama models, use existing pull functionality
                if (currentSearchTab === "ollama") {
                    // Pull first model (existing pull modal only supports one at a time)
                    document.getElementById("pull-model-input").value = modelNames[0];
                    document.getElementById("pull-btn").click();

                    // TODO: Queue remaining models or enhance pull modal for batch
                } else {
                    // For HuggingFace, just show info (no pull needed - uses Inference API)
                    alert(`HuggingFace models don't need to be pulled.\n\nYou can use them directly via the Inference API:\n${modelNames.join("\n")}`);
                }
            });

            /* ---------- Init ---------- */
            window.addEventListener("load", () => {
                loadEndpoints();
                loadTags();
                loadPS();
                loadUsage();
                setInterval(loadPS, 60_000);
                setInterval(loadEndpoints, 300_000);

                // Initialize model search after a short delay to ensure table is loaded
                setTimeout(initModelSearch, 500);
            });
        </script>

        <div id="show-modal" class="modal">
            <div class="modal-content">
                <span class="close-btn">&times;</span>
                <h2>Model details</h2>
                <pre id="json-output"></pre>
            </div>
        </div>

        <!-- Pull Progress Modal -->
        <div id="pull-modal">
            <div id="pull-modal-content">
                <span class="pull-close-btn">&times;</span>
                <h2>Pulling Model: <span id="pull-modal-model"></span></h2>
                <div id="pull-progress-container">
                    <!-- Progress items populated dynamically -->
                </div>
                <div class="pull-control-buttons">
                    <button class="pull-cancel-btn" id="pull-cancel-btn">Cancel</button>
                    <button class="pull-restart-btn" id="pull-restart-btn">Restart</button>
                </div>
            </div>
        </div>

        <!-- Search & Pull Modal -->
        <div id="search-modal" class="modal">
            <div class="modal-content search-modal-content">
                <span class="close-btn" onclick="document.getElementById('search-modal').style.display='none'">&times;</span>
                <h2>Search & Pull Models</h2>

                <!-- Tabs -->
                <div class="search-tabs">
                    <button class="tab-btn active" data-tab="ollama">Ollama</button>
                    <button class="tab-btn" data-tab="hf">HuggingFace</button>
                </div>

                <!-- Hardware Status Panel -->
                <div class="hw-status-panel">
                    <h3 style="margin-top: 0;">Hardware Status</h3>
                    <div class="hw-metric">
                        <span>üíæ Disk Space:</span>
                        <span id="hw-disk" class="hw-value">Loading...</span>
                    </div>
                    <div class="hw-metric">
                        <span>üß† RAM Available:</span>
                        <span id="hw-ram" class="hw-value">Loading...</span>
                    </div>
                    <div class="hw-metric">
                        <span>‚öôÔ∏è CPU Cores:</span>
                        <span id="hw-cpu" class="hw-value">Loading...</span>
                    </div>
                </div>

                <!-- Search Input -->
                <div style="margin-bottom: 1rem;">
                    <input
                        type="text"
                        id="model-search-input"
                        placeholder="Search models..."
                        style="width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid #ccc; border-radius: 4px;"
                    />
                </div>

                <!-- Results -->
                <div class="search-results" id="search-results">
                    <div style="padding: 2rem; text-align: center; color: #999;">
                        Enter a search term or browse all models
                    </div>
                </div>

                <!-- Actions -->
                <div class="search-actions">
                    <button onclick="document.getElementById('search-modal').style.display='none'">Cancel</button>
                    <button id="pull-selected-btn" disabled>Pull Selected</button>
                </div>
            </div>
        </div>
    </body>
</html>
